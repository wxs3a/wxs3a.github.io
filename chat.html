<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: white;
    min-height: 100vh;
    color: #333;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

header {
    background: white;
    padding: 20px;
    border-radius: 15px;
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border: 1px solid #e2e8f0;
}

header h1 {
    color: #4a5568;
    font-size: 24px;
}

.status {
    display: flex;
    gap: 15px;
}

#status {
    padding: 5px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
}

#status.online {
    background: #48bb78;
    color: white;
}

#status.offline {
    background: #e53e3e;
    color: white;
}

#peer-count {
    background: #4299e1;
    color: white;
    padding: 5px 12px;
    border-radius: 20px;
    font-size: 12px;
}

.connection-panel {
    background: white;
    padding: 20px;
    border-radius: 15px;
    margin-bottom: 20px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    border: 1px solid #e2e8f0;
}

.connection-panel input {
    flex: 1;
    min-width: 200px;
    padding: 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 14px;
}

.connection-panel button {
    padding: 12px 20px;
    background: #4299e1;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.2s;
}

.connection-panel button:hover {
    background: #3182ce;
}

.chat-container {
    background: white;
    border-radius: 15px;
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid #e2e8f0;
}

.chat-header {
    padding: 15px 20px;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    align-items: center;
    gap: 15px;
}

#session-select {
    padding: 8px 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: white;
    min-width: 200px;
}

#current-session {
    font-weight: bold;
    color: #4a5568;
}

.messages {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.message {
    max-width: 70%;
    padding: 12px 16px;
    border-radius: 18px;
    word-wrap: break-word;
    position: relative;
}

.message.sent {
    align-self: flex-end;
    background: #4299e1;
    color: white;
}

.message.received {
    align-self: flex-start;
    background: #f7fafc;
    border: 1px solid #e2e8f0;
}

.message .time {
    font-size: 11px;
    opacity: 0.7;
    margin-top: 4px;
}

.message.encrypted::before {
    content: "ğŸ”’";
    position: absolute;
    top: -5px;
    right: -5px;
    font-size: 12px;
}

.input-area {
    padding: 20px;
    border-top: 1px solid #e2e8f0;
    display: flex;
    gap: 10px;
}

.input-area input {
    flex: 1;
    padding: 12px;
    border: 2px solid #e2e8f0;
    border-radius: 25px;
    font-size: 14px;
}

.input-area button {
    padding: 12px 24px;
    background: #48bb78;
    color: white;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.2s;
}

.input-area button:hover:not(:disabled) {
    background: #38a169;
}

.input-area button:disabled {
    background: #cbd5e0;
    cursor: not-allowed;
}

#image-btn {
    background: #ed8936 !important;
    padding: 12px 16px !important;
    font-size: 16px;
}

#file-btn {
    background: #9f7aea !important;
    padding: 12px 16px !important;
    font-size: 16px;
}

.file-message {
    background: #f7fafc;
    border: 2px dashed #cbd5e0;
    padding: 15px;
    border-radius: 8px;
    margin-top: 5px;
    cursor: pointer;
    transition: background 0.2s;
}

.file-message:hover {
    background: #edf2f7;
}

.file-info {
    display: flex;
    align-items: center;
    gap: 10px;
}

.file-icon {
    font-size: 24px;
}

.file-details {
    flex: 1;
}

.file-name {
    font-weight: bold;
    color: #2d3748;
}

.file-size {
    font-size: 12px;
    color: #718096;
}

.message img {
    max-width: 300px;
    max-height: 300px;
    border-radius: 8px;
    margin-top: 5px;
    cursor: pointer;
    object-fit: contain;
}

.system-message {
    text-align: center;
    color: #718096;
    font-size: 12px;
    font-style: italic;
    margin: 10px 0;
}

.menu-container #dropdown-menu div:hover {
    background: #edf2f7;
}

#menu-btn:hover {
    background: #edf2f7;
}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Demo</h1>
            <div class="status">
                <span id="status">ç¦»çº¿</span>
                <span id="peer-count">å·²è¿æ¥çš„èŠ‚ç‚¹: 0</span>
            </div>
        </header>

        <div class="connection-panel">
            <input type="text" id="peer-id" placeholder="è¾“å…¥å¯¹æ–¹IDè¿æ¥..." readonly>
            <button id="copy-id">å¤åˆ¶æˆ‘çš„ID</button>
            <input type="text" id="connect-id" placeholder="ç²˜è´´å¯¹æ–¹ID">
            <button id="connect-btn">è¿æ¥</button>
        </div>

        <div class="chat-container">
            <div class="chat-header">
                <select id="session-select" disabled>
                    <option value="">é€‰æ‹©ä¼šè¯...</option>
                </select>
                <span id="current-session">æ— æ´»åŠ¨ä¼šè¯</span>
                <div class="security-indicator" style="display: none;">
                    <span id="security-code">å®‰å…¨ç : ------</span>
                    <button id="verify-btn" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">éªŒè¯</button>
                </div>
                <div class="menu-container" style="position: relative; margin-left: auto;">
                    <button id="menu-btn" style="padding: 8px 12px; font-size: 16px; background: #f7fafc; border: 2px solid #e2e8f0; border-radius: 8px; cursor: pointer; transition: background 0.2s;">â‹®</button>
                    <div id="dropdown-menu" style="display: none; position: absolute; right: 0; top: 100%; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 160px;">
                        <div id="export-btn" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #e2e8f0; font-size: 14px; color: #4a5568;">å¯¼å‡ºèŠå¤©è®°å½•</div>
                        <div id="history-btn" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #e2e8f0; font-size: 14px; color: #4a5568;">èŠå¤©è®°å½•ç®¡ç†</div>
                        <div id="contacts-btn" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #e2e8f0; font-size: 14px; color: #4a5568;">è”ç³»äºº</div>
                        <div id="reset-btn" style="padding: 12px 16px; cursor: pointer; font-size: 14px; color: #e53e3e;">é‡ç½®è´¦æˆ·</div>
                    </div>
                </div>
            </div>
            <div id="messages" class="messages"></div>
            <div class="input-area">
                <input type="file" id="file-input" accept="image/*" style="display: none;">
                <input type="file" id="document-input" style="display: none;">
                <button id="image-btn" disabled>ğŸ“·</button>
                <button id="file-btn" disabled>ğŸ“</button>
                <input type="text" id="message-input" placeholder="é€‰æ‹©ä¼šè¯åè¾“å…¥æ¶ˆæ¯..." disabled>
                <button id="send-btn" disabled>å‘é€</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script>
class DistributedChat {
    constructor() {
        this.PROTOCOL_VERSION = '1.0.0';
        this.peer = null;
        this.connections = new Map();
        this.peerKeys = new Map();
        this.sessionMessages = new Map();
        this.currentSession = null;
        this.fileBuffers = new Map();
        this.keyPairs = new Map();
        this.publicKeys = new Map();
        this.fingerprints = new Map();
        this.messageCounters = new Map();
        this.receivedCounters = new Map();
        this.chainKeys = new Map();
        this.db = null;
        this.userId = null;
        this.masterKeyPair = null;
        this.init();
    }

    async init() {
        try {
            await this.initDB();
            await this.initUser();
            this.setupPeer();
            this.setupEventListeners();
            this.updateStatus('ç¦»çº¿', 'offline');
        } catch (error) {
            console.error('åˆå§‹åŒ–å¤±è´¥:', error);
            alert('åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢');
        }
    }

    async initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('SecureChatDB', 3);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                if (!db.objectStoreNames.contains('keyPairs')) {
                    db.createObjectStore('keyPairs', { keyPath: 'id' });
                }
                
                if (!db.objectStoreNames.contains('messages')) {
                    const messageStore = db.createObjectStore('messages', { keyPath: 'id', autoIncrement: true });
                    messageStore.createIndex('peerId', 'peerId', { unique: false });
                    messageStore.createIndex('timestamp', 'timestamp', { unique: false });
                }
                
                if (!db.objectStoreNames.contains('users')) {
                    db.createObjectStore('users', { keyPath: 'id' });
                }
                
                if (!db.objectStoreNames.contains('contacts')) {
                    const contactStore = db.createObjectStore('contacts', { keyPath: 'peerId' });
                    contactStore.createIndex('lastConnected', 'lastConnected', { unique: false });
                }
                
                if (!db.objectStoreNames.contains('trustedKeys')) {
                    db.createObjectStore('trustedKeys', { keyPath: 'peerId' });
                }
            };
        });
    }

    async initUser() {
        const userData = await this.getFromDB('users', 'current');
        
        if (!userData) {
            const userId = prompt('è¯·è¾“å…¥åç§°:ï¼ˆä»»æ„é•¿åº¦çš„è‹±æ–‡å­—ç¬¦ï¼Œä¼šæ·»åŠ å‰ç¼€å’Œåç¼€ï¼‰');
            if (!userId) {
                alert('å¿…é¡»è¾“å…¥åç§°æ‰èƒ½ä½¿ç”¨èŠå¤©åŠŸèƒ½');
                location.reload();
                return;
            }
            
            this.userId = 'sechat_e2e_' + userId + '_' + Date.now().toString(36);
            
            // ç”Ÿæˆä¸»å¯†é’¥å¯¹
            this.masterKeyPair = await this.generateRSAKeyPair();
            
            // å­˜å‚¨ç”¨æˆ·æ•°æ®
            await this.saveToDB('users', {
                id: 'current',
                userId: this.userId,
                created: new Date().toISOString()
            });
            
            // å­˜å‚¨å¯†é’¥å¯¹
            const publicKey = await this.exportPublicKey(this.masterKeyPair.publicKey);
            const privateKey = await crypto.subtle.exportKey('pkcs8', this.masterKeyPair.privateKey);
            
            await this.saveToDB('keyPairs', {
                id: 'master',
                publicKey: publicKey,
                privateKey: btoa(String.fromCharCode(...new Uint8Array(privateKey)))
            });
            
            this.addSystemMessage(`ğŸ†• æ¬¢è¿ ${this.userId}ï¼æ‚¨çš„èº«ä»½å·²ä¿å­˜`);
        } else {
            this.userId = userData.userId;
            
            // åŠ è½½å¯†é’¥å¯¹
            const keyData = await this.getFromDB('keyPairs', 'master');
            if (keyData) {
                const publicKey = await this.importPublicKey(keyData.publicKey);
                const privateKeyData = Uint8Array.from(atob(keyData.privateKey), c => c.charCodeAt(0));
                const privateKey = await crypto.subtle.importKey(
                    'pkcs8',
                    privateKeyData,
                    { name: 'RSA-OAEP', hash: 'SHA-256' },
                    true, // extractable: true
                    ['decrypt']
                );
                
                this.masterKeyPair = { publicKey, privateKey };
            }
            
            this.addSystemMessage(`ğŸ‘‹ æ¬¢è¿å›æ¥ ${this.userId}`);
        }
    }

    async saveToDB(storeName, data) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put(data);
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    async getFromDB(storeName, key) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(key);
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    async checkIPv6Support() {
        try {
            // ä½¿ç”¨æ›´ç®€å•çš„IPv6æ£€æµ‹æ–¹æ³•
            const response = await fetch('https://[2001:4860:4860::8888]:443', { 
                method: 'HEAD',
                mode: 'no-cors',
                signal: AbortSignal.timeout(3000)
            });
            this.addSystemMessage('ğŸŒ IPv6æ”¯æŒå·²å¯ç”¨ï¼Œè¿æ¥æ›´ç¨³å®š');
        } catch (e) {
            // IPv6ä¸å¯ç”¨æˆ–ç½‘ç»œé™åˆ¶ï¼Œä½¿ç”¨IPv4
            console.log('IPv6æ£€æµ‹å¤±è´¥:', e.message);
        }
    }

    generateKey() {
        return CryptoJS.lib.WordArray.random(256/8).toString();
    }

    async generateRSAKeyPair() {
        const keyPair = await crypto.subtle.generateKey(
            {
                name: 'RSA-OAEP',
                modulusLength: 2048,
                publicExponent: new Uint8Array([1, 0, 1]),
                hash: 'SHA-256'
            },
            true, // extractable: true å…è®¸å¯¼å‡ºå…¬é’¥
            ['encrypt', 'decrypt']
        );
        return keyPair;
    }

    async exportPublicKey(publicKey) {
        try {
            const exported = await crypto.subtle.exportKey('spki', publicKey);
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        } catch (error) {
            console.error('å¯¼å‡ºå…¬é’¥å¤±è´¥:', error);
            // é™çº§æ–¹æ¡ˆï¼šç”Ÿæˆä¼ªé€ çš„base64å­—ç¬¦ä¸²
            const fakeKey = 'FALLBACK_' + btoa(JSON.stringify({id: this.userId, time: Date.now()}));
            return fakeKey;
        }
    }

    async importPublicKey(keyData) {
        try {
            if (keyData.startsWith('FALLBACK_')) {
                // é™çº§æ–¹æ¡ˆï¼šè¿”å›ä¼ªé€ å…¬é’¥å¯¹è±¡
                return { _isFallback: true, keyData: keyData };
            }
            
            const binaryKey = Uint8Array.from(atob(keyData), c => c.charCodeAt(0));
            return await crypto.subtle.importKey(
                'spki',
                binaryKey,
                { name: 'RSA-OAEP', hash: 'SHA-256' },
                true, // extractable: true
                ['encrypt']
            );
        } catch (error) {
            console.error('å¯¼å…¥å…¬é’¥å¤±è´¥:', error);
            return { _isFallback: true, keyData: keyData };
        }
    }

    async generateFingerprint(publicKeyStr) {
        try {
            const encoder = new TextEncoder();
            const data = encoder.encode(publicKeyStr);
            const hash = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hash));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 6).toUpperCase();
        } catch (error) {
            // é™çº§åˆ°ç®€å•å“ˆå¸Œ
            let hash = 0;
            for (let i = 0; i < publicKeyStr.length; i++) {
                const char = publicKeyStr.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(16).substring(0, 6).toUpperCase();
        }
    }

    setupPeer() {
        this.peer = new Peer(this.userId, {
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' },
                    { urls: 'stun:stun.voipbuster.com' },
                    { urls: 'stun:[2001:4860:4860::8888]:19302' },
                    { urls: 'stun:[2001:4860:4860::8844]:19302' },
                    { urls: 'stun:[2620:119:35::35]:3478' },
                    { urls: 'stun:[2001:67c:2b0::1]:3478' },
                    { urls: 'stun:[2a00:1450:400c:c05::7f]:19302' }
                ],
                iceCandidatePoolSize: 10,
                bundlePolicy: 'balanced',
                rtcpMuxPolicy: 'require'
            }
        });

        this.peer.on('open', (id) => {
            document.getElementById('peer-id').value = id;
            this.updateStatus('åœ¨çº¿', 'online');
            this.addSystemMessage(`ğŸŸ¢ å·²è¿æ¥åˆ°ç½‘ç»œï¼Œæ‚¨çš„ID: ${id}`);
        });

        this.peer.on('connection', (conn) => {
            // è¢«åŠ¨æ¥æ”¶çš„è¿æ¥æ˜ç¡®æ ‡è®°ä¸ºéä¸»åŠ¨
            conn.metadata = { initiator: false };
            this.handleConnection(conn);
        });

        this.peer.on('error', (err) => {
            console.error('Peer error:', err);
            this.addSystemMessage('âŒ è¿æ¥é”™è¯¯: ' + err.message);
        });
    }

    setupEventListeners() {
        document.getElementById('copy-id').addEventListener('click', () => {
            const peerId = document.getElementById('peer-id').value;
            navigator.clipboard.writeText(peerId);
            this.addSystemMessage('ğŸ“‹ IDå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
        });

        document.getElementById('connect-btn').addEventListener('click', () => {
            const targetId = document.getElementById('connect-id').value.trim();
            if (targetId) {
                this.connectToPeer(targetId);
            }
        });

        document.getElementById('message-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendMessage();
            }
        });

        document.getElementById('send-btn').addEventListener('click', () => {
            this.sendMessage();
        });

        document.getElementById('session-select').addEventListener('change', (e) => {
            this.switchSession(e.target.value);
        });

        document.getElementById('image-btn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                this.sendImage(file);
            }
        });

        document.getElementById('file-btn').addEventListener('click', () => {
            document.getElementById('document-input').click();
        });

        document.getElementById('document-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                this.sendFile(file);
            }
        });

        document.getElementById('verify-btn').addEventListener('click', () => {
            if (this.currentSession) {
                const fingerprint = this.fingerprints.get(this.currentSession);
                const verified = confirm(`è¯·é€šè¿‡è¯­éŸ³æˆ–è§†é¢‘æ ¸å¯¹å®‰å…¨ç :\n\næ‚¨çš„å®‰å…¨ç : ${fingerprint}\nå¯¹æ–¹å®‰å…¨ç : è¯·å¯¹æ–¹æä¾›\n\nç‚¹å‡»â€œç¡®å®šâ€è¡¨ç¤ºå®‰å…¨ç ä¸€è‡´\nç‚¹å‡»â€œå–æ¶ˆâ€å°†æ–­å¼€è¿æ¥`);
                
                if (!verified) {
                    this.addSystemMessage('âŒ å®‰å…¨éªŒè¯å¤±è´¥ï¼Œæ­£åœ¨æ–­å¼€è¿æ¥...');
                    this.disconnectPeer(this.currentSession);
                } else {
                    this.addSystemMessage('âœ… å®‰å…¨éªŒè¯æˆåŠŸï¼Œè¿æ¥å®‰å…¨');
                }
            }
        });

        // ä¸‹æ‹‰èœå•äº‹ä»¶
        document.getElementById('menu-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            const menu = document.getElementById('dropdown-menu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        });

        // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
        document.addEventListener('click', () => {
            document.getElementById('dropdown-menu').style.display = 'none';
        });

        document.getElementById('export-btn').addEventListener('click', () => {
            this.exportChatHistory();
            document.getElementById('dropdown-menu').style.display = 'none';
        });

        document.getElementById('history-btn').addEventListener('click', () => {
            this.showHistoryManager();
            document.getElementById('dropdown-menu').style.display = 'none';
        });

        document.getElementById('contacts-btn').addEventListener('click', () => {
            this.showContacts();
            document.getElementById('dropdown-menu').style.display = 'none';
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            this.resetAccount();
            document.getElementById('dropdown-menu').style.display = 'none';
        });
    }

    connectToPeer(peerId) {
        if (this.connections.has(peerId)) {
            this.addSystemMessage('âš ï¸ å·²ç»è¿æ¥åˆ°è¯¥èŠ‚ç‚¹');
            return;
        }



        const conn = this.peer.connect(peerId);
        conn.metadata = { initiator: true }; // æ ‡è®°ä¸ºä¸»åŠ¨è¿æ¥æ–¹
        this.handleConnection(conn);
    }

    handleConnection(conn) {
        conn.on('open', () => {
            this.connections.set(conn.peer, conn);
            this.sessionMessages.set(conn.peer, []); // åˆå§‹åŒ–ä¼šè¯æ¶ˆæ¯
            this.updatePeerCount();
            this.updateSessionList();
            this.addSystemMessageToSession(conn.peer, 'ğŸ¤ å·²è¿æ¥åˆ°èŠ‚ç‚¹: ' + conn.peer);
            
            // ä¿å­˜è”ç³»äºº
            this.saveContact(conn.peer);
            
            // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªè¿æ¥ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°è¯¥ä¼šè¯
            if (this.connections.size === 1) {
                this.switchSession(conn.peer);
            }
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºä¸»åŠ¨è¿æ¥
            console.log('è°ƒè¯•: è¿æ¥ç±»å‹', {
                peer: conn.peer.substring(0, 8),
                hasMetadata: !!conn.metadata,
                isInitiator: !!(conn.metadata && conn.metadata.initiator)
            });
            
            // ä½¿ç”¨æŒä¹…åŒ–çš„ä¸»å¯†é’¥å¯¹
            if (!this.masterKeyPair) {
                console.error('ä¸»å¯†é’¥å¯¹æœªåˆå§‹åŒ–');
                return;
            }
            
            this.keyPairs.set(conn.peer, this.masterKeyPair);
            this.exportPublicKey(this.masterKeyPair.publicKey).then(publicKeyStr => {
                // å‘é€å…¬é’¥å’Œåè®®ç‰ˆæœ¬
                conn.send({
                    type: 'public-key',
                    publicKey: publicKeyStr,
                    protocolVersion: this.PROTOCOL_VERSION
                });
                
                // ä¸»åŠ¨è¿æ¥æ–¹ç­‰å¾…å…¬é’¥äº¤æ¢å®Œæˆåå‘é€ä¼šè¯å¯†é’¥
                if (conn.metadata && conn.metadata.initiator) {
                    conn._waitingForPublicKey = true;
                }
            });
        });

        conn.on('data', (data) => {
            this.handleMessage(data, conn.peer);
        });

        conn.on('close', () => {
            this.connections.delete(conn.peer);
            this.peerKeys.delete(conn.peer);
            this.updatePeerCount();
            this.updateSessionList();
            
            // å¦‚æœå…³é—­çš„æ˜¯å½“å‰ä¼šè¯ï¼Œåˆ‡æ¢åˆ°å…¶ä»–ä¼šè¯
            if (this.currentSession === conn.peer) {
                const remainingSessions = Array.from(this.connections.keys());
                if (remainingSessions.length > 0) {
                    this.switchSession(remainingSessions[0]);
                } else {
                    this.switchSession(null);
                }
            }
            
            if (this.connections.size === 0) {
                this.disableChat();
            }
        });

        conn.on('error', (err) => {
            console.error('Connection error:', err);
            this.addSystemMessage('âŒ è¿æ¥é”™è¯¯: ' + err.message);
        });
    }

    handleMessage(data, peerId) {
        if (data.type === 'public-key') {
            // æ£€æŸ¥åè®®ç‰ˆæœ¬å…¼å®¹æ€§
            if (data.protocolVersion && data.protocolVersion !== this.PROTOCOL_VERSION) {
                this.addSystemMessageToSession(peerId, `âš ï¸ åè®®ç‰ˆæœ¬ä¸åŒ¹é…: æœ¬åœ°${this.PROTOCOL_VERSION} vs å¯¹æ–¹${data.protocolVersion}`);
            }
            this.importPublicKey(data.publicKey).then(publicKey => {
                this.publicKeys.set(peerId, publicKey);
                
                // ç”Ÿæˆå…±åŒå®‰å…¨ç ï¼šåŸºäºåŒæ–¹å…¬é’¥çš„ç»„åˆ
                const myKeyPair = this.keyPairs.get(peerId);
                if (myKeyPair) {
                    return this.exportPublicKey(myKeyPair.publicKey).then(myPublicKey => {
                        const combinedKeys = [myPublicKey, data.publicKey].sort().join('');
                        return this.generateFingerprint(combinedKeys);
                    });
                }
            }).then(fingerprint => {
                this.fingerprints.set(peerId, fingerprint);
                this.addSystemMessageToSession(peerId, `ğŸ”‘ å®‰å…¨ç : ${fingerprint}`);
                
                // å¦‚æœæ˜¯å½“å‰ä¼šè¯ï¼Œç«‹å³æ˜¾ç¤ºå®‰å…¨ç 
                if (this.currentSession === peerId) {
                    document.getElementById('security-code').textContent = `å®‰å…¨ç : ${fingerprint}`;
                    document.querySelector('.security-indicator').style.display = 'block';
                }
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºå¯ä¿¡å…¬é’¥
                this.checkTrustedKey(peerId, data.publicKey, fingerprint);
                
                // ä¸»åŠ¨è¿æ¥æ–¹ç°åœ¨å‘é€ä¼šè¯å¯†é’¥
                const conn = this.connections.get(peerId);
                if (conn && conn._waitingForPublicKey) {
                    this.sendSessionKey(peerId);
                    conn._waitingForPublicKey = false;
                }
            });
            return;
        }

        if (data.type === 'encrypted-key') {
            const keyPair = this.keyPairs.get(peerId);
            if (keyPair) {
                if (data._isFallback) {
                    // é™çº§æ–¹æ¡ˆï¼šç›´æ¥è§£ç 
                    const sessionKey = atob(data.encryptedKey);
                    this.peerKeys.set(peerId, sessionKey);
                    this.chainKeys.set(peerId, CryptoJS.SHA256(sessionKey + 'send_chain').toString());
                    this.messageCounters.set(peerId, 0);
                    this.receivedCounters.set(peerId, 0);
                    this.addSystemMessageToSession(peerId, 'ğŸ” ä¼šè¯å¯†é’¥å·²æ¥æ”¶');
                    
                    const conn = this.connections.get(peerId);
                    if (conn) {
                        const confirmMsg = this.encryptWithKey('å¯†é’¥ç¡®è®¤æˆåŠŸ', sessionKey);
                        conn.send({ type: 'key-confirm', encrypted: confirmMsg });
                    }
                } else {
                    crypto.subtle.decrypt(
                        { name: 'RSA-OAEP' },
                        keyPair.privateKey,
                        Uint8Array.from(atob(data.encryptedKey), c => c.charCodeAt(0))
                    ).then(decryptedKey => {
                        const sessionKey = new TextDecoder().decode(decryptedKey);
                        this.peerKeys.set(peerId, sessionKey);
                        this.chainKeys.set(peerId, CryptoJS.SHA256(sessionKey + 'send_chain').toString());
                        this.messageCounters.set(peerId, 0);
                        this.receivedCounters.set(peerId, 0);
                        this.addSystemMessageToSession(peerId, 'ğŸ” ä¼šè¯å¯†é’¥å·²è§£å¯†');
                        
                        const conn = this.connections.get(peerId);
                        if (conn) {
                            const confirmMsg = this.encryptWithKey('å¯†é’¥ç¡®è®¤æˆåŠŸ', sessionKey);
                            conn.send({ type: 'key-confirm', encrypted: confirmMsg });
                        }
                    }).catch(error => {
                        console.error('RSAè§£å¯†å¤±è´¥:', error);
                        this.addSystemMessageToSession(peerId, 'âŒ å¯†é’¥è§£å¯†å¤±è´¥');
                    });
                }
            }
            return;
        }

        if (data.type === 'key-confirm') {
            const sessionKey = this.peerKeys.get(peerId);
            if (sessionKey && data.encrypted) {
                const decrypted = this.decryptWithKey(data.encrypted, sessionKey);
                if (decrypted === 'å¯†é’¥ç¡®è®¤æˆåŠŸ') {
                    // ä¸»åŠ¨æ–¹åˆå§‹åŒ–æ¥æ”¶é“¾
                    // å‘é€é“¾å·²åœ¨sendSessionKeyä¸­åˆå§‹åŒ–
                    this.addSystemMessageToSession(peerId, 'âœ… å®‰å…¨è¿æ¥å·²å»ºç«‹');
                } else {
                    this.addSystemMessageToSession(peerId, 'âŒ å¯†é’¥éªŒè¯å¤±è´¥');
                }
            }
            return;
        }

        if (data.type === 'message') {
            const peerKey = this.peerKeys.get(peerId);
            if (!peerKey) {
                this.addMessageToSession(peerId, 'âš ï¸ æœªæ‰¾åˆ°å¯†é’¥', 'received', false);
                return;
            }
            
            // æ£€æŸ¥æ¶ˆæ¯ç‰ˆæœ¬å…¼å®¹æ€§
            if (data.version && data.version !== this.PROTOCOL_VERSION) {
                this.addSystemMessageToSession(peerId, `âš ï¸ æ¶ˆæ¯ç‰ˆæœ¬ä¸åŒ¹é…: ${data.version}`);
            }
            
            const decrypted = this.decryptWithRatchet(data.content, peerId);
            if (decrypted && !decrypted.startsWith('[')) {
                this.addMessageToSession(peerId, decrypted, 'received', true);
            } else {
                this.addMessageToSession(peerId, decrypted || 'â“ è§£å¯†å¤±è´¥', 'received', false);
            }
        }

        if (data.type === 'image') {
            const peerKey = this.peerKeys.get(peerId);
            if (!peerKey) {
                this.addMessageToSession(peerId, 'âš ï¸ æœªæ‰¾åˆ°å¯†é’¥', 'received', false);
                return;
            }
            
            this.addSystemMessage('ğŸ”„ æ­£åœ¨è§£å¯†å›¾ç‰‡...');
            this.decryptWithKeyAsync(data.content, peerKey).then(decrypted => {
                if (decrypted && decrypted !== '[è§£å¯†å¤±è´¥]') {
                    this.addImageToSession(peerId, decrypted, 'received', true);
                } else {
                    this.addMessageToSession(peerId, 'â“ å›¾ç‰‡è§£å¯†å¤±è´¥', 'received', false);
                }
            });
        }

        // å¤„ç†åˆ†å—æ–‡ä»¶ä¼ è¾“
        if (data.type === 'file-start') {
            this.fileBuffers.set(data.fileId, {
                filename: data.filename,
                filesize: data.filesize,
                filetype: data.filetype,
                totalChunks: data.totalChunks,
                chunks: new Array(data.totalChunks),
                receivedChunks: 0
            });
            this.addSystemMessage(`ğŸ“¥ æ­£åœ¨æ¥æ”¶æ–‡ä»¶: ${data.filename}`);
            return;
        }

        if (data.type === 'file-chunk') {
            const fileBuffer = this.fileBuffers.get(data.fileId);
            if (fileBuffer) {
                fileBuffer.chunks[data.chunkIndex] = data.chunk;
                fileBuffer.receivedChunks++;
                
                const progress = Math.round((fileBuffer.receivedChunks / fileBuffer.totalChunks) * 100);
                this.addSystemMessage(`ğŸ“¥ æ¥æ”¶è¿›åº¦: ${progress}%`);
            }
            return;
        }

        if (data.type === 'file-end') {
            const fileBuffer = this.fileBuffers.get(data.fileId);
            if (fileBuffer && fileBuffer.receivedChunks === fileBuffer.totalChunks) {
                this.processFileBuffer(fileBuffer, peerId);
            }
            this.fileBuffers.delete(data.fileId);
            return;
        }

        if (data.type === 'file') {
            const peerKey = this.peerKeys.get(peerId);
            if (!peerKey) {
                this.addMessageToSession(peerId, 'âš ï¸ æœªæ‰¾åˆ°å¯†é’¥', 'received', false);
                return;
            }
            
            this.addSystemMessage(`ğŸ”„ æ­£åœ¨è§£å¯†æ–‡ä»¶: ${data.filename}`);
            this.decryptWithKeyAsync(data.content, peerKey).then(decrypted => {
                if (decrypted && decrypted !== '[è§£å¯†å¤±è´¥]') {
                    this.addFileToSession(peerId, {
                        data: decrypted,
                        name: data.filename,
                        size: data.filesize,
                        type: data.filetype
                    }, 'received', true);
                } else {
                    this.addMessageToSession(peerId, 'â“ æ–‡ä»¶è§£å¯†å¤±è´¥', 'received', false);
                }
            });
        }
    }

    sendMessage() {
        const input = document.getElementById('message-input');
        const message = input.value.trim();
        
        if (!message || !this.currentSession) return;

        const peerKey = this.peerKeys.get(this.currentSession);
        const conn = this.connections.get(this.currentSession);
        
        if (peerKey && conn) {
            const encrypted = this.encryptWithRatchet(message, this.currentSession);
            
            conn.send({
                type: 'message',
                content: encrypted,
                version: this.PROTOCOL_VERSION
            });
            
            this.addMessageToSession(this.currentSession, message, 'sent', true);
            this.refreshCurrentSession();
        }

        input.value = '';
    }

    async sendImage(file) {
        if (!this.currentSession || file.size > 100 * 1024 * 1024) {
            this.addSystemMessage('âš ï¸ å›¾ç‰‡è¿‡å¤§ï¼ˆé™åˆ¶100MBï¼‰');
            return;
        }

        this.addSystemMessage('ğŸ”„ æ­£åœ¨åŠ å¯†å›¾ç‰‡...');
        
        const reader = new FileReader();
        reader.onload = async (e) => {
            const imageData = e.target.result;
            const peerKey = this.peerKeys.get(this.currentSession);
            const conn = this.connections.get(this.currentSession);
            
            if (peerKey && conn) {
                try {
                    const encrypted = await this.encryptWithKeyAsync(imageData, peerKey);
                    
                    conn.send({
                        type: 'image',
                        content: encrypted,
                        filename: file.name
                    });
                    
                    this.addImageToSession(this.currentSession, imageData, 'sent', true);
                    this.refreshCurrentSession();
                    this.addSystemMessage('âœ… å›¾ç‰‡å‘é€æˆåŠŸ');
                } catch (error) {
                    this.addSystemMessage('âŒ å›¾ç‰‡åŠ å¯†å¤±è´¥');
                }
            }
        };
        reader.readAsDataURL(file);
        
        document.getElementById('file-input').value = '';
    }

    async sendFile(file) {
        if (!this.currentSession || file.size > 1024 * 1024 * 1024) {
            this.addSystemMessage('âš ï¸ æ–‡ä»¶è¿‡å¤§ï¼ˆé™åˆ¶1Gï¼‰');
            return;
        }

        this.addSystemMessage(`ğŸ”„ æ­£åœ¨åŠ å¯†æ–‡ä»¶: ${file.name} (${this.formatFileSize(file.size)})`);
        
        const reader = new FileReader();
        reader.onload = async (e) => {
            const fileData = e.target.result;
            const peerKey = this.peerKeys.get(this.currentSession);
            const conn = this.connections.get(this.currentSession);
            
            if (peerKey && conn) {
                try {
                    const encrypted = await this.encryptWithKeyAsync(fileData, peerKey);
                    
                    await this.sendFileInChunks(conn, {
                        type: 'file',
                        content: encrypted,
                        filename: file.name,
                        filesize: file.size,
                        filetype: file.type
                    });
                    
                    this.addFileToSession(this.currentSession, {
                        data: fileData,
                        name: file.name,
                        size: file.size,
                        type: file.type
                    }, 'sent', true);
                    this.refreshCurrentSession();
                    this.addSystemMessage('âœ… æ–‡ä»¶å‘é€æˆåŠŸ');
                } catch (error) {
                    this.addSystemMessage('âŒ æ–‡ä»¶åŠ å¯†å¤±è´¥');
                }
            }
        };
        reader.readAsDataURL(file);
        
        document.getElementById('document-input').value = '';
    }

    encryptWithKey(message, key) {
        const encrypted = CryptoJS.AES.encrypt(message, key).toString();
        const hmac = CryptoJS.HmacSHA256(encrypted, key).toString();
        return encrypted + '|' + hmac;
    }

    decryptWithKey(encryptedMessage, key) {
        try {
            const parts = encryptedMessage.split('|');
            if (parts.length !== 2) return '[è§£å¯†å¤±è´¥]';
            
            const [encrypted, receivedHmac] = parts;
            const computedHmac = CryptoJS.HmacSHA256(encrypted, key).toString();
            
            if (computedHmac !== receivedHmac) {
                console.warn('HMACéªŒè¯å¤±è´¥ï¼Œå¯èƒ½é­åˆ°ç¯¡æ”¹');
                return '[æ¶ˆæ¯è¢«ç¯¡æ”¹]';
            }
            
            const bytes = CryptoJS.AES.decrypt(encrypted, key);
            return bytes.toString(CryptoJS.enc.Utf8);
        } catch (e) {
            return '[è§£å¯†å¤±è´¥]';
        }
    }

    // åˆ†å—åŠ å¯†ï¼Œå‡å°‘å†…å­˜å ç”¨
    async encryptWithKeyAsync(message, key) {
        const chunkSize = 4 * 1024 * 1024; // 4MBåˆ†å—
        
        if (message.length <= chunkSize) {
            // å°æ–‡ä»¶ç›´æ¥åŠ å¯†
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        resolve(CryptoJS.AES.encrypt(message, key).toString());
                    } catch (error) {
                        reject(error);
                    }
                }, 10);
            });
        }
        
        // å¤§æ–‡ä»¶åˆ†å—åŠ å¯†
        const chunks = [];
        for (let i = 0; i < message.length; i += chunkSize) {
            const chunk = message.slice(i, i + chunkSize);
            
            await new Promise(resolve => setTimeout(resolve, 10)); // è®©å‡ºUIçº¿ç¨‹
            
            const encrypted = CryptoJS.AES.encrypt(chunk, key).toString();
            chunks.push(encrypted);
        }
        
        return JSON.stringify(chunks);
    }

    // åˆ†å—è§£å¯†
    async decryptWithKeyAsync(encryptedMessage, key) {
        try {
            // å°è¯•è§£æä¸ºåˆ†å—æ•°æ®
            const chunks = JSON.parse(encryptedMessage);
            if (Array.isArray(chunks)) {
                // åˆ†å—è§£å¯†
                const decryptedChunks = [];
                for (const chunk of chunks) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                    
                    const bytes = CryptoJS.AES.decrypt(chunk, key);
                    const decrypted = bytes.toString(CryptoJS.enc.Utf8);
                    decryptedChunks.push(decrypted);
                }
                return decryptedChunks.join('');
            }
        } catch (e) {
            // ä¸æ˜¯åˆ†å—æ•°æ®ï¼Œä½¿ç”¨æ™®é€šè§£å¯†
        }
        
        // æ™®é€šè§£å¯†
        return new Promise((resolve) => {
            setTimeout(() => {
                try {
                    const bytes = CryptoJS.AES.decrypt(encryptedMessage, key);
                    const decrypted = bytes.toString(CryptoJS.enc.Utf8);
                    resolve(decrypted || '[è§£å¯†å¤±è´¥]');
                } catch (error) {
                    resolve('[è§£å¯†å¤±è´¥]');
                }
            }, 10);
        });
    }

    // ä¿ç•™åŸæœ‰æ–¹æ³•ç”¨äºå…¼å®¹
    addMessage(content, type, encrypted = false) {
        this.displayMessage(content, type, encrypted);
    }

    addSystemMessage(content) {
        this.displaySystemMessage(content);
    }

    updateStatus(status, className) {
        const statusEl = document.getElementById('status');
        statusEl.textContent = status;
        statusEl.className = className;
    }

    updatePeerCount() {
        document.getElementById('peer-count').textContent = `å·²è¿æ¥çš„èŠ‚ç‚¹: ${this.connections.size}`;
    }

    enableChat() {
        if (this.currentSession) {
            document.getElementById('message-input').disabled = false;
            document.getElementById('send-btn').disabled = false;
            document.getElementById('image-btn').disabled = false;
            document.getElementById('file-btn').disabled = false;
        }
        document.getElementById('session-select').disabled = false;
    }

    disableChat() {
        document.getElementById('message-input').disabled = true;
        document.getElementById('send-btn').disabled = true;
        document.getElementById('image-btn').disabled = true;
        document.getElementById('file-btn').disabled = true;
        document.getElementById('session-select').disabled = true;
    }

    // æ–°å¢ä¼šè¯ç®¡ç†æ–¹æ³•
    updateSessionList() {
        const select = document.getElementById('session-select');
        const currentValue = select.value;
        select.innerHTML = '<option value="">é€‰æ‹©ä¼šè¯...</option>';
        
        this.connections.forEach((conn, peerId) => {
            const option = document.createElement('option');
            option.value = peerId;
            
            // ä½¿ç”¨è”ç³»äººæ˜¾ç¤ºåç§°
            this.getFromDB('contacts', peerId).then(contact => {
                const displayName = contact?.displayName || peerId.substring(0, 12) + '...';
                option.textContent = displayName;
            });
            
            if (peerId === currentValue) {
                option.selected = true;
            }
            select.appendChild(option);
        });
        
        select.disabled = this.connections.size === 0;
    }

    async switchSession(peerId) {
        if (!peerId || !this.connections.has(peerId)) {
            this.currentSession = null;
            document.getElementById('current-session').textContent = 'æ— æ´»åŠ¨ä¼šè¯';
            document.getElementById('message-input').disabled = true;
            document.getElementById('send-btn').disabled = true;
            document.querySelector('.security-indicator').style.display = 'none';
            this.clearMessages();
            return;
        }
        
        this.currentSession = peerId;
        // ä½¿ç”¨è”ç³»äººæ˜¾ç¤ºåç§°ä½œä¸ºä¼šè¯å
        this.getFromDB('contacts', peerId).then(contact => {
            const displayName = contact?.displayName || peerId.substring(0, 12) + '...';
            document.getElementById('current-session').textContent = 'ä¼šè¯: ' + displayName;
        });
        document.getElementById('message-input').disabled = false;
        document.getElementById('send-btn').disabled = false;
        document.getElementById('image-btn').disabled = false;
        document.getElementById('file-btn').disabled = false;
        document.getElementById('message-input').placeholder = 'è¾“å…¥æ¶ˆæ¯...';
        
        // æ˜¾ç¤ºå®‰å…¨ç 
        const fingerprint = this.fingerprints.get(peerId);
        if (fingerprint) {
            document.getElementById('security-code').textContent = `å®‰å…¨ç : ${fingerprint}`;
            document.querySelector('.security-indicator').style.display = 'block';
        }
        
        // åŠ è½½å†å²æ¶ˆæ¯
        await this.loadHistoryMessages(peerId);
        this.refreshCurrentSession();
    }

    refreshCurrentSession() {
        this.clearMessages();
        const messages = this.sessionMessages.get(this.currentSession) || [];
        messages.forEach(msg => {
            if (msg.messageType === 'image') {
                this.displayImage(msg.content, msg.type, msg.encrypted);
            } else if (msg.messageType === 'file') {
                this.displayFile(msg.content, msg.type, msg.encrypted);
            } else {
                this.displayMessage(msg.content, msg.type, msg.encrypted);
            }
        });
    }

    addMessageToSession(peerId, content, type, encrypted = false) {
        if (!this.sessionMessages.has(peerId)) {
            this.sessionMessages.set(peerId, []);
        }
        
        const message = { content, type, encrypted, time: new Date(), messageType: 'text' };
        this.sessionMessages.get(peerId).push(message);
        
        // ä¿å­˜åˆ°IndexedDB
        this.saveToDB('messages', {
            peerId: peerId,
            content: content,
            type: type,
            encrypted: encrypted,
            messageType: 'text',
            timestamp: new Date().toISOString()
        });
        
        if (this.currentSession === peerId) {
            this.displayMessage(content, type, encrypted);
        }
    }

    addImageToSession(peerId, imageData, type, encrypted = false) {
        if (!this.sessionMessages.has(peerId)) {
            this.sessionMessages.set(peerId, []);
        }
        
        const message = { content: imageData, type, encrypted, time: new Date(), messageType: 'image' };
        this.sessionMessages.get(peerId).push(message);
        
        if (this.currentSession === peerId) {
            this.displayImage(imageData, type, encrypted);
        }
    }

    addFileToSession(peerId, fileInfo, type, encrypted = false) {
        if (!this.sessionMessages.has(peerId)) {
            this.sessionMessages.set(peerId, []);
        }
        
        const message = { content: fileInfo, type, encrypted, time: new Date(), messageType: 'file' };
        this.sessionMessages.get(peerId).push(message);
        
        if (this.currentSession === peerId) {
            this.displayFile(fileInfo, type, encrypted);
        }
    }

    addSystemMessageToSession(peerId, content) {
        if (!this.sessionMessages.has(peerId)) {
            this.sessionMessages.set(peerId, []);
        }
        
        const message = { content, type: 'system', encrypted: false, time: new Date() };
        this.sessionMessages.get(peerId).push(message);
        
        if (this.currentSession === peerId) {
            this.displaySystemMessage(content);
        }
    }

    clearMessages() {
        document.getElementById('messages').innerHTML = '';
    }

    displayMessage(content, type, encrypted = false) {
        const messagesDiv = document.getElementById('messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}${encrypted ? ' encrypted' : ''}`;
        
        const time = new Date().toLocaleTimeString();
        messageDiv.innerHTML = `
            <div>${content}</div>
            <div class="time">${time}</div>
        `;
        
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    displaySystemMessage(content) {
        const messagesDiv = document.getElementById('messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'system-message';
        messageDiv.textContent = content;
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    displayImage(imageData, type, encrypted = false) {
        const messagesDiv = document.getElementById('messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}${encrypted ? ' encrypted' : ''}`;
        
        const time = new Date().toLocaleTimeString();
        const img = document.createElement('img');
        img.src = imageData;
        img.onclick = () => window.open(imageData, '_blank');
        
        messageDiv.innerHTML = `
            <div>ğŸ–¼ï¸ å›¾ç‰‡</div>
            <div class="time">${time}</div>
        `;
        messageDiv.insertBefore(img, messageDiv.querySelector('.time'));
        
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    displayFile(fileInfo, type, encrypted = false) {
        const messagesDiv = document.getElementById('messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}${encrypted ? ' encrypted' : ''}`;
        
        const time = new Date().toLocaleTimeString();
        const fileSize = this.formatFileSize(fileInfo.size);
        const fileIcon = this.getFileIcon(fileInfo.type);
        
        messageDiv.innerHTML = `
            <div class="file-message">
                <div class="file-info">
                    <div class="file-icon">${fileIcon}</div>
                    <div class="file-details">
                        <div class="file-name">${fileInfo.name}</div>
                        <div class="file-size">${fileSize}</div>
                    </div>
                </div>
            </div>
            <div class="time">${time}</div>
        `;
        
        const fileMessage = messageDiv.querySelector('.file-message');
        fileMessage.onclick = () => {
            console.log('ä¸‹è½½æ–‡ä»¶:', fileInfo.name);
            this.downloadFile(fileInfo.data, fileInfo.name);
        };
        
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    getFileIcon(fileType) {
        if (fileType.startsWith('image/')) return 'ğŸ–¼ï¸';
        if (fileType.startsWith('video/')) return 'ğŸ¥';
        if (fileType.startsWith('audio/')) return 'ğŸ§';
        if (fileType.includes('pdf')) return 'ğŸ“„';
        if (fileType.includes('word')) return 'ğŸ“„';
        if (fileType.includes('excel') || fileType.includes('spreadsheet')) return 'ğŸ“ˆ';
        if (fileType.includes('zip') || fileType.includes('rar')) return 'ğŸ—œï¸';
        return 'ğŸ“';
    }

    // åˆ†å—å‘é€æ–‡ä»¶
    async sendFileInChunks(conn, fileData) {
        const maxChunkSize = 64 * 1024 * 1024; // 16MBåˆ†å—
        const content = fileData.content;
        
        if (content.length <= maxChunkSize) {
            conn.send(fileData);
            return;
        }
        
        const fileId = Date.now().toString();
        const totalChunks = Math.ceil(content.length / maxChunkSize);
        
        // å‘é€æ–‡ä»¶å¤´ä¿¡æ¯
        conn.send({
            type: 'file-start',
            fileId: fileId,
            filename: fileData.filename,
            filesize: fileData.filesize,
            filetype: fileData.filetype,
            totalChunks: totalChunks
        });
        
        // åˆ†å—å‘é€
        for (let i = 0; i < totalChunks; i++) {
            const start = i * maxChunkSize;
            const end = Math.min(start + maxChunkSize, content.length);
            const chunk = content.slice(start, end);
            
            conn.send({
                type: 'file-chunk',
                fileId: fileId,
                chunkIndex: i,
                chunk: chunk
            });
            
            await new Promise(resolve => setTimeout(resolve, 10));
        }
        
        // å‘é€ç»“æŸä¿¡å·
        conn.send({
            type: 'file-end',
            fileId: fileId
        });
    }

    async processFileBuffer(fileBuffer, peerId) {
        const content = fileBuffer.chunks.join('');
        const peerKey = this.peerKeys.get(peerId);
        
        if (peerKey) {
            this.addSystemMessage(`ğŸ”„ æ­£åœ¨è§£å¯†æ–‡ä»¶: ${fileBuffer.filename}`);
            const decrypted = await this.decryptWithKeyAsync(content, peerKey);
            if (decrypted && decrypted !== '[è§£å¯†å¤±è´¥]') {
                this.addFileToSession(peerId, {
                    data: decrypted,
                    name: fileBuffer.filename,
                    size: fileBuffer.filesize,
                    type: fileBuffer.filetype
                }, 'received', true);
            } else {
                this.addMessageToSession(peerId, 'â“ æ–‡ä»¶è§£å¯†å¤±è´¥', 'received', false);
            }
        }
    }

    async sendSessionKey(peerId) {
        const sessionKey = this.generateKey();
        this.peerKeys.set(peerId, sessionKey);
        this.chainKeys.set(peerId, CryptoJS.SHA256(sessionKey + 'send_chain').toString());
        this.messageCounters.set(peerId, 0);
        this.receivedCounters.set(peerId, 0);
        
        const publicKey = this.publicKeys.get(peerId);
        if (publicKey) {
            const conn = this.connections.get(peerId);
            if (conn) {
                if (publicKey._isFallback) {
                    // é™çº§æ–¹æ¡ˆï¼šç›´æ¥å‘é€æ˜æ–‡å¯†é’¥
                    conn.send({
                        type: 'encrypted-key',
                        encryptedKey: btoa(sessionKey),
                        _isFallback: true
                    });
                } else {
                    try {
                        const keyBuffer = new TextEncoder().encode(sessionKey);
                        const encryptedKey = await crypto.subtle.encrypt(
                            { name: 'RSA-OAEP' },
                            publicKey,
                            keyBuffer
                        );
                        
                        conn.send({
                            type: 'encrypted-key',
                            encryptedKey: btoa(String.fromCharCode(...new Uint8Array(encryptedKey)))
                        });
                    } catch (error) {
                        console.error('RSAåŠ å¯†å¤±è´¥:', error);
                        // é™çº§åˆ°æ˜æ–‡ä¼ è¾“
                        conn.send({
                            type: 'encrypted-key',
                            encryptedKey: btoa(sessionKey),
                            _isFallback: true
                        });
                    }
                }
                this.addSystemMessageToSession(peerId, 'ğŸ”‘ å·²å‘é€ä¼šè¯å¯†é’¥');
            }
        }
    }

    deriveNextKey(currentKey) {
        return CryptoJS.SHA256(currentKey + 'next').toString();
    }

    encryptWithRatchet(message, peerId) {
        const sessionKey = this.peerKeys.get(peerId);
        const counter = this.messageCounters.get(peerId) || 0;
        
        if (!sessionKey) return this.encryptWithKey(message, sessionKey);
        
        // ç®€åŒ–ï¼šç›´æ¥ä½¿ç”¨ä¼šè¯å¯†é’¥+è®¡æ•°å™¨
        const messageKey = CryptoJS.HmacSHA256(`${this.peer.id}_${counter}`, sessionKey).toString();
        
        this.messageCounters.set(peerId, counter + 1);
        
        const payload = JSON.stringify({ counter, message, sender: this.peer.id });
        return this.encryptWithKey(payload, messageKey);
    }

    decryptWithRatchet(encryptedMessage, peerId) {
        const sessionKey = this.peerKeys.get(peerId);
        if (!sessionKey) return this.decryptWithKey(encryptedMessage, sessionKey);
        
        try {
            const expectedCounter = (this.receivedCounters.get(peerId) || 0);
            
            // å°è¯•ä½¿ç”¨å¯¹æ–¹çš„å‘é€è€…ID+è®¡æ•°å™¨è§£å¯†
            const messageKey = CryptoJS.HmacSHA256(`${peerId}_${expectedCounter}`, sessionKey).toString();
            
            const decrypted = this.decryptWithKey(encryptedMessage, messageKey);
            if (decrypted.startsWith('[')) {
                return this.decryptWithKey(encryptedMessage, sessionKey);
            }
            
            const payload = JSON.parse(decrypted);
            if (payload.counter !== expectedCounter || payload.sender !== peerId) {
                return '[æ¶ˆæ¯éªŒè¯å¤±è´¥]';
            }
            
            this.receivedCounters.set(peerId, expectedCounter + 1);
            return payload.message;
        } catch (e) {
            return this.decryptWithKey(encryptedMessage, sessionKey);
        }
    }

    disconnectPeer(peerId) {
        const conn = this.connections.get(peerId);
        if (conn) {
            conn.close();
        }
        this.connections.delete(peerId);
        this.peerKeys.delete(peerId);
        this.keyPairs.delete(peerId);
        this.publicKeys.delete(peerId);
        this.fingerprints.delete(peerId);
        
        this.updatePeerCount();
        this.updateSessionList();
        
        if (this.currentSession === peerId) {
            this.switchSession(null);
        }
    }

    async saveContact(peerId) {
        const existingContact = await this.getFromDB('contacts', peerId);
        const displayName = existingContact?.displayName || peerId.split('_')[2] || peerId;
        
        await this.saveToDB('contacts', {
            peerId: peerId,
            lastConnected: new Date().toISOString(),
            displayName: displayName
        });
    }

    async exportChatHistory() {
        if (!this.currentSession) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªä¼šè¯');
            return;
        }
        
        const messages = this.sessionMessages.get(this.currentSession) || [];
        let chatText = 'èŠå¤©è®°å½• - ' + this.currentSession + '\n';
        chatText += 'å¯¼å‡ºæ—¶é—´: ' + new Date().toLocaleString() + '\n';
        chatText += '==================================================\n\n';
        
        messages.forEach(msg => {
            const time = new Date(msg.time).toLocaleString();
            const type = msg.type === 'sent' ? 'æˆ‘' : 'å¯¹æ–¹';
            const encrypted = msg.encrypted ? 'ğŸ”’' : '';
            
            if (msg.messageType === 'text') {
                chatText += '[' + time + '] ' + type + encrypted + ': ' + msg.content + '\n';
            } else if (msg.messageType === 'image') {
                chatText += '[' + time + '] ' + type + encrypted + ': [å›¾ç‰‡]\n';
            } else if (msg.messageType === 'file') {
                chatText += '[' + time + '] ' + type + encrypted + ': [æ–‡ä»¶: ' + msg.content.name + ']\n';
            }
        });
        
        const blob = new Blob([chatText], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const filename = `èŠå¤©è®°å½•_${this.currentSession}_${new Date().toISOString().split('T')[0]}.txt`;
        
        this.downloadFile(url, filename);
        URL.revokeObjectURL(url);
    }

    async showContacts() {
        const transaction = this.db.transaction(['contacts'], 'readonly');
        const store = transaction.objectStore('contacts');
        const request = store.getAll();
        
        request.onsuccess = () => {
            const contacts = request.result;
            if (contacts.length === 0) {
                alert('æš‚æ— è”ç³»äºº');
                return;
            }
            
            // åˆ›å»ºå¼¹çª—
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:1000;display:flex;align-items:center;justify-content:center';
            
            const dialog = document.createElement('div');
            dialog.style.cssText = 'background:white;padding:20px;border-radius:10px;max-width:400px;width:90%;max-height:500px;overflow-y:auto';
            
            const title = document.createElement('h3');
            title.textContent = 'è”ç³»äººåˆ—è¡¨';
            title.style.marginBottom = '15px';
            dialog.appendChild(title);
            
            const tip = document.createElement('div');
            tip.textContent = 'åŒå‡»è¿æ¥ï¼Œå³é”®é‡å‘½å';
            tip.style.cssText = 'font-size: 12px; color: #718096; margin-bottom: 10px; text-align: center;';
            dialog.appendChild(tip);
            
            const list = document.createElement('div');
            contacts.forEach(contact => {
                const item = document.createElement('div');
                item.style.cssText = 'padding:10px;border:1px solid #ddd;margin:5px 0;border-radius:5px;cursor:pointer;transition:background 0.2s';
                item.innerHTML = `<strong>${contact.displayName}</strong><br><small>${contact.peerId}</small><br><small>æœ€åè¿æ¥: ${new Date(contact.lastConnected).toLocaleString()}</small>`;
                
                item.onmouseover = () => item.style.background = '#f0f0f0';
                item.onmouseout = () => item.style.background = 'white';
                item.ondblclick = () => {
                    this.connectToPeer(contact.peerId);
                    document.body.removeChild(modal);
                };
                
                item.oncontextmenu = (e) => {
                    e.preventDefault();
                    const newName = prompt('è¾“å…¥æ–°çš„æ˜¾ç¤ºåç§°:', contact.displayName);
                    if (newName && newName.trim()) {
                        contact.displayName = newName.trim();
                        this.saveToDB('contacts', contact);
                        item.innerHTML = `<strong>${contact.displayName}</strong><br><small>${contact.peerId}</small><br><small>æœ€åè¿æ¥: ${new Date(contact.lastConnected).toLocaleString()}</small>`;
                    }
                };
                
                list.appendChild(item);
            });
            
            const closeBtn = document.createElement('div');
            closeBtn.innerHTML = 'Ã—';
            closeBtn.style.cssText = 'position:absolute;top:10px;right:15px;font-size:24px;cursor:pointer;color:#999;font-weight:bold';
            closeBtn.onclick = () => document.body.removeChild(modal);
            closeBtn.onmouseover = () => closeBtn.style.color = '#000';
            closeBtn.onmouseout = () => closeBtn.style.color = '#999';
            
            dialog.style.position = 'relative';
            
            dialog.appendChild(closeBtn);
            dialog.appendChild(list);
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) document.body.removeChild(modal);
            };
        };
    }

    async checkTrustedKey(peerId, publicKey, fingerprint) {
        const trustedKey = await this.getFromDB('trustedKeys', peerId);
        
        if (!trustedKey) {
            // é¦–æ¬¡è¿æ¥ï¼Œéœ€è¦éªŒè¯
            setTimeout(() => {
                const verified = confirm(`âš ï¸ é¦–æ¬¡è¿æ¥å®‰å…¨éªŒè¯\n\nè¯·é€šè¿‡è¯­éŸ³æˆ–è§†é¢‘æ ¸å¯¹å®‰å…¨ç :\n\næ‚¨çš„å®‰å…¨ç : ${fingerprint}\nå¯¹æ–¹å®‰å…¨ç : è¯·å¯¹æ–¹æä¾›\n\nç‚¹å‡»â€œç¡®å®šâ€è¡¨ç¤ºå®‰å…¨ç ä¸€è‡´\nç‚¹å‡»â€œå–æ¶ˆâ€å°†æ–­å¼€è¿æ¥`);
                
                if (!verified) {
                    this.addSystemMessage('âŒ å®‰å…¨éªŒè¯å¤±è´¥ï¼Œæ­£åœ¨æ–­å¼€è¿æ¥...');
                    this.disconnectPeer(peerId);
                } else {
                    // ä¿å­˜å¯ä¿¡å…¬é’¥
                    this.saveToDB('trustedKeys', {
                        peerId: peerId,
                        publicKey: publicKey,
                        fingerprint: fingerprint,
                        trustedAt: new Date().toISOString()
                    });
                    this.addSystemMessage('âœ… å®‰å…¨éªŒè¯æˆåŠŸï¼Œå…¬é’¥å·²ä¿å­˜');
                    // éšè—å®‰å…¨ç å’ŒéªŒè¯æŒ‰é’®
                    if (this.currentSession === peerId) {
                        document.querySelector('.security-indicator').style.display = 'none';
                    }
                }
            }, 1000);
        } else if (trustedKey.publicKey !== publicKey) {
            // å¯¹æ–¹å…¬é’¥å˜æ›´ï¼Œå¯èƒ½é­åˆ°ä¸­é—´äººæ”»å‡»
            const verified = confirm(`âš ï¸ å®‰å…¨è­¦å‘Š\n\næ£€æµ‹åˆ°å¯¹æ–¹å…¬é’¥å˜æ›´ï¼å¯èƒ½é­åˆ°ä¸­é—´äººæ”»å‡»ã€‚\n\nè¯·é€šè¿‡å®‰å…¨æ¸ é“ç¡®è®¤å¯¹æ–¹æ˜¯å¦æ›´æ¢äº†è®¾å¤‡æˆ–é‡æ–°ç”Ÿæˆäº†å¯†é’¥\n\næ–°å®‰å…¨ç : ${fingerprint}\n\nç‚¹å‡»â€œç¡®å®šâ€æ›´æ–°å…¬é’¥\nç‚¹å‡»â€œå–æ¶ˆâ€æ–­å¼€è¿æ¥`);
            
            if (!verified) {
                this.addSystemMessage('âŒ å…¬é’¥éªŒè¯å¤±è´¥ï¼Œæ­£åœ¨æ–­å¼€è¿æ¥...');
                this.disconnectPeer(peerId);
            } else {
                // æ›´æ–°å…¬é’¥
                this.saveToDB('trustedKeys', {
                    peerId: peerId,
                    publicKey: publicKey,
                    fingerprint: fingerprint,
                    trustedAt: new Date().toISOString()
                });
                this.addSystemMessage('âœ… å…¬é’¥å·²æ›´æ–°');
                // éšè—å®‰å…¨ç å’ŒéªŒè¯æŒ‰é’®
                if (this.currentSession === peerId) {
                    document.querySelector('.security-indicator').style.display = 'none';
                }
            }
        } else {
            // å…¬é’¥ä¸€è‡´ï¼Œè‡ªåŠ¨é€šè¿‡
            this.addSystemMessage('âœ… å¯ä¿¡è”ç³»äººï¼Œå·²è‡ªåŠ¨éªŒè¯');
            // éšè—å®‰å…¨ç å’ŒéªŒè¯æŒ‰é’®
            if (this.currentSession === peerId) {
                document.querySelector('.security-indicator').style.display = 'none';
            }
        }
    }

    async loadHistoryMessages(peerId) {
        const transaction = this.db.transaction(['messages'], 'readonly');
        const store = transaction.objectStore('messages');
        const index = store.index('peerId');
        const request = index.getAll(peerId);
        
        return new Promise((resolve) => {
            request.onsuccess = () => {
                const historyMessages = request.result;
                
                // åˆå¹¶å†å²æ¶ˆæ¯å’Œå½“å‰ä¼šè¯æ¶ˆæ¯
                const currentMessages = this.sessionMessages.get(peerId) || [];
                const allMessages = [...historyMessages, ...currentMessages];
                
                // æŒ‰æ—¶é—´æ’åºå¹¶å»é‡
                const uniqueMessages = allMessages.reduce((acc, msg) => {
                    const key = msg.timestamp || msg.time?.toISOString() || new Date().toISOString();
                    if (!acc.find(m => (m.timestamp || m.time?.toISOString()) === key && m.content === msg.content)) {
                        acc.push(msg);
                    }
                    return acc;
                }, []).sort((a, b) => {
                    const timeA = new Date(a.timestamp || a.time);
                    const timeB = new Date(b.timestamp || b.time);
                    return timeA - timeB;
                });
                
                this.sessionMessages.set(peerId, uniqueMessages);
                resolve();
            };
        });
    }

    async showHistoryManager() {
        const transaction = this.db.transaction(['messages', 'contacts'], 'readonly');
        const messageStore = transaction.objectStore('messages');
        const contactStore = transaction.objectStore('contacts');
        
        const messageRequest = messageStore.getAll();
        const contactRequest = contactStore.getAll();
        
        messageRequest.onsuccess = () => {
            contactRequest.onsuccess = () => {
                const messages = messageRequest.result || [];
                const contacts = contactRequest.result || [];
            // æŒ‰è”ç³»äººåˆ†ç»„æ¶ˆæ¯
            const messagesByPeer = {};
            messages.forEach(msg => {
                if (!messagesByPeer[msg.peerId]) {
                    messagesByPeer[msg.peerId] = [];
                }
                messagesByPeer[msg.peerId].push(msg);
            });
            
            // åˆ›å»ºå¼¹çª—
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:1000;display:flex;align-items:center;justify-content:center';
            
            const dialog = document.createElement('div');
            dialog.style.cssText = 'background:white;padding:20px;border-radius:10px;max-width:500px;width:90%;max-height:600px;overflow-y:auto;position:relative';
            
            const closeBtn = document.createElement('div');
            closeBtn.innerHTML = 'Ã—';
            closeBtn.style.cssText = 'position:absolute;top:10px;right:15px;font-size:24px;cursor:pointer;color:#999;font-weight:bold';
            closeBtn.onclick = () => document.body.removeChild(modal);
            closeBtn.onmouseover = () => closeBtn.style.color = '#000';
            closeBtn.onmouseout = () => closeBtn.style.color = '#999';
            
            const title = document.createElement('h3');
            title.textContent = 'èŠå¤©è®°å½•ç®¡ç†';
            title.style.marginBottom = '15px';
            
            const list = document.createElement('div');
            
            Object.keys(messagesByPeer).forEach(peerId => {
                const contact = contacts.find(c => c.peerId === peerId);
                const displayName = contact?.displayName || peerId.split('_')[2] || peerId;
                const messageCount = messagesByPeer[peerId].length;
                const lastMessage = messagesByPeer[peerId].sort((a, b) => new Date(b.timestamp || b.time) - new Date(a.timestamp || a.time))[0];
                const lastTime = new Date(lastMessage.timestamp || lastMessage.time).toLocaleString();
                
                const item = document.createElement('div');
                item.style.cssText = 'padding:15px;border:1px solid #e2e8f0;margin:8px 0;border-radius:8px;background:#f7fafc';
                item.innerHTML = `
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                        <strong>${displayName}</strong>
                        <span style="font-size:12px;color:#718096">${messageCount}æ¡æ¶ˆæ¯</span>
                    </div>
                    <div style="font-size:12px;color:#718096;margin-bottom:10px">æœ€åæ¶ˆæ¯: ${lastTime}</div>
                    <div style="display:flex;gap:8px">
                        <button class="export-single" style="padding:6px 12px;background:#4299e1;color:white;border:none;border-radius:4px;cursor:pointer;font-size:12px">å¯¼å‡º</button>
                        <button class="delete-history" style="padding:6px 12px;background:#e53e3e;color:white;border:none;border-radius:4px;cursor:pointer;font-size:12px">åˆ é™¤</button>
                    </div>
                `;
                
                // å¯¼å‡ºå•ä¸ªè”ç³»äººçš„èŠå¤©è®°å½•
                item.querySelector('.export-single').onclick = () => {
                    this.exportSingleHistory(peerId, displayName, messagesByPeer[peerId]);
                };
                
                // åˆ é™¤èŠå¤©è®°å½•
                item.querySelector('.delete-history').onclick = () => {
                    if (confirm(`ç¡®å®šè¦åˆ é™¤ä¸ ${displayName} çš„æ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼`)) {
                        this.deleteHistory(peerId);
                        document.body.removeChild(modal);
                        this.addSystemMessage(`âœ… å·²åˆ é™¤ä¸ ${displayName} çš„èŠå¤©è®°å½•`);
                    }
                };
                
                list.appendChild(item);
            });
            
            if (Object.keys(messagesByPeer).length === 0) {
                list.innerHTML = '<div style="text-align:center;color:#718096;padding:20px">æš‚æ— èŠå¤©è®°å½•</div>';
            }
            
            dialog.appendChild(closeBtn);
            dialog.appendChild(title);
            dialog.appendChild(list);
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) document.body.removeChild(modal);
            };
            };
        };
    }

    exportSingleHistory(peerId, displayName, messages) {
        let chatText = `èŠå¤©è®°å½• - ${displayName}\n`;
        chatText += `å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}\n`;
        chatText += '==================================================\n\n';
        
        messages.sort((a, b) => new Date(a.timestamp || a.time) - new Date(b.timestamp || b.time)).forEach(msg => {
            const time = new Date(msg.timestamp || msg.time).toLocaleString();
            const type = msg.type === 'sent' ? 'æˆ‘' : 'å¯¹æ–¹';
            const encrypted = msg.encrypted ? 'ğŸ”’' : '';
            
            if (msg.messageType === 'text') {
                chatText += '[' + time + '] ' + type + encrypted + ': ' + msg.content + '\n';
            } else if (msg.messageType === 'image') {
                chatText += '[' + time + '] ' + type + encrypted + ': [å›¾ç‰‡]\n';
            } else if (msg.messageType === 'file') {
                chatText += '[' + time + '] ' + type + encrypted + ': [æ–‡ä»¶: ' + msg.content.name + ']\n';
            }
        });
        
        const blob = new Blob([chatText], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const filename = 'èŠå¤©è®°å½•_' + displayName + '_' + new Date().toISOString().split('T')[0] + '.txt';
        
        this.downloadFile(url, filename);
        URL.revokeObjectURL(url);
    }

    async deleteHistory(peerId) {
        const transaction = this.db.transaction(['messages'], 'readwrite');
        const store = transaction.objectStore('messages');
        const index = store.index('peerId');
        const request = index.openCursor(peerId);
        
        request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
                cursor.delete();
                cursor.continue();
            }
        };
        
        // æ¸…ç©ºå†…å­˜ä¸­çš„æ¶ˆæ¯
        this.sessionMessages.delete(peerId);
        if (this.currentSession === peerId) {
            this.clearMessages();
        }
    }

    resetAccount() {
        if (confirm('ç¡®å®šè¦é‡ç½®è´¦æˆ·å—ï¼Ÿè¿™å°†æ¸…é™¤æ‰€æœ‰æ•°æ®å¹¶é‡æ–°åˆ›å»ºè´¦æˆ·ï¼')) {
            // å…³é—­æ‰€æœ‰è¿æ¥
            this.connections.forEach(conn => conn.close());
            this.connections.clear();
            
            // å…³é—­Peerè¿æ¥
            if (this.peer) {
                this.peer.destroy();
            }
            
            // æ¸…é™¤IndexedDB
            if (this.db) {
                this.db.close();
            }
            
            const deleteRequest = indexedDB.deleteDatabase('SecureChatDB');
            deleteRequest.onsuccess = () => {
                // åˆ·æ–°é¡µé¢é‡æ–°åˆå§‹åŒ–
                location.reload();
            };
            
            deleteRequest.onerror = () => {
                alert('é‡ç½®å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨åˆ·æ–°é¡µé¢');
                location.reload();
            };
        }
    }

    downloadFile(dataUrl, filename) {
        try {
            const safeName = filename && filename.trim() ? filename.trim() : 'download';
            
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = safeName;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (error) {
            console.error('ä¸‹è½½å¤±è´¥:', error);
            window.open(dataUrl, '_blank');
        }
    }
}

// å¯åŠ¨åº”ç”¨
document.addEventListener('DOMContentLoaded', () => {
    new DistributedChat();
});
    </script>
</body>
</html>